//! ISO 42001 Report Generator
//!
//! Generates audit reports in various formats.

use super::{AuditReport as AuditReportData, ComplianceFinding, FindingSeverity};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

/// Report format.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ReportFormat {
    Json,
    Markdown,
    Html,
    Pdf,
}

/// Generated audit report.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuditReport {
    pub organization_id: String,
    pub system_version: String,
    pub period_start: DateTime<Utc>,
    pub period_end: DateTime<Utc>,
    pub generated_at: DateTime<Utc>,
    pub total_ai_decisions: usize,
    pub denied_actions: usize,
    pub human_oversight_percentage: f64,
    pub high_risk_actions: usize,
    pub compliance_score: u8,
    pub findings: Vec<ComplianceFinding>,
}

impl AuditReport {
    /// Export to specified format.
    pub fn export(&self, format: ReportFormat) -> String {
        match format {
            ReportFormat::Json => self.to_json(),
            ReportFormat::Markdown => self.to_markdown(),
            ReportFormat::Html => self.to_html(),
            ReportFormat::Pdf => self.to_markdown(), // Placeholder
        }
    }
    
    fn to_json(&self) -> String {
        serde_json::to_string_pretty(self).unwrap_or_default()
    }
    
    fn to_markdown(&self) -> String {
        let mut md = String::new();
        
        md.push_str("# ISO/IEC 42001 AI Management System Audit Report\n\n");
        md.push_str(&format!("**Organization**: {}\n\n", self.organization_id));
        md.push_str(&format!("**System Version**: {}\n\n", self.system_version));
        md.push_str(&format!("**Period**: {} to {}\n\n", 
            self.period_start.format("%Y-%m-%d"),
            self.period_end.format("%Y-%m-%d")
        ));
        md.push_str(&format!("**Generated**: {}\n\n", self.generated_at.format("%Y-%m-%d %H:%M:%S UTC")));
        
        md.push_str("---\n\n");
        md.push_str("## Executive Summary\n\n");
        md.push_str(&format!("| Metric | Value |\n"));
        md.push_str("|--------|-------|\n");
        md.push_str(&format!("| Total AI Decisions | {} |\n", self.total_ai_decisions));
        md.push_str(&format!("| Denied Actions | {} |\n", self.denied_actions));
        md.push_str(&format!("| Human Oversight | {:.1}% |\n", self.human_oversight_percentage));
        md.push_str(&format!("| High Risk Actions | {} |\n", self.high_risk_actions));
        md.push_str(&format!("| **Compliance Score** | **{}**/100 |\n\n", self.compliance_score));
        
        if !self.findings.is_empty() {
            md.push_str("## Findings\n\n");
            for (i, finding) in self.findings.iter().enumerate() {
                md.push_str(&format!("### Finding {}: {} ({})\n\n", 
                    i + 1, 
                    finding.category,
                    match finding.severity {
                        FindingSeverity::Critical => "ðŸ”´ Critical",
                        FindingSeverity::High => "ðŸŸ  High",
                        FindingSeverity::Medium => "ðŸŸ¡ Medium",
                        FindingSeverity::Low => "ðŸŸ¢ Low",
                    }
                ));
                md.push_str(&format!("**Description**: {}\n\n", finding.description));
                md.push_str(&format!("**Recommendation**: {}\n\n", finding.recommendation));
            }
        } else {
            md.push_str("## Findings\n\nNo compliance findings identified. âœ…\n\n");
        }
        
        md.push_str("---\n\n");
        md.push_str("*Report generated by VeriMantle ISO 42001 Compliance Module*\n");
        
        md
    }
    
    fn to_html(&self) -> String {
        let md = self.to_markdown();
        format!(
            r#"<!DOCTYPE html>
<html>
<head>
    <title>ISO 42001 Audit Report - {}</title>
    <style>
        body {{ font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }}
        table {{ border-collapse: collapse; width: 100%; margin: 20px 0; }}
        th, td {{ border: 1px solid #ddd; padding: 12px; text-align: left; }}
        th {{ background-color: #4CAF50; color: white; }}
        h1 {{ color: #333; }}
        h2 {{ color: #666; border-bottom: 2px solid #4CAF50; padding-bottom: 10px; }}
        .score {{ font-size: 48px; font-weight: bold; color: {}; }}
    </style>
</head>
<body>
    <pre>{}</pre>
</body>
</html>"#,
            self.organization_id,
            if self.compliance_score >= 80 { "#4CAF50" } else if self.compliance_score >= 60 { "#FF9800" } else { "#F44336" },
            md
        )
    }
}

/// Report generator with scheduling.
pub struct ReportGenerator {
    organization_id: String,
}

impl ReportGenerator {
    /// Create a new report generator.
    pub fn new(organization_id: String) -> Self {
        Self { organization_id }
    }
    
    /// Generate report from audit events.
    pub fn generate(&self, report: &AuditReport, format: ReportFormat) -> String {
        report.export(format)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn create_test_report() -> AuditReport {
        AuditReport {
            organization_id: "TEST-ORG".to_string(),
            system_version: "1.0.0".to_string(),
            period_start: Utc::now() - chrono::Duration::days(30),
            period_end: Utc::now(),
            generated_at: Utc::now(),
            total_ai_decisions: 1500,
            denied_actions: 25,
            human_oversight_percentage: 45.5,
            high_risk_actions: 10,
            compliance_score: 92,
            findings: vec![],
        }
    }

    #[test]
    fn test_markdown_export() {
        let report = create_test_report();
        let md = report.export(ReportFormat::Markdown);
        
        assert!(md.contains("ISO/IEC 42001"));
        assert!(md.contains("TEST-ORG"));
        assert!(md.contains("92"));
    }

    #[test]
    fn test_json_export() {
        let report = create_test_report();
        let json = report.export(ReportFormat::Json);
        
        assert!(json.contains("organization_id"));
        assert!(json.contains("compliance_score"));
    }

    #[test]
    fn test_html_export() {
        let report = create_test_report();
        let html = report.export(ReportFormat::Html);
        
        assert!(html.contains("<!DOCTYPE html>"));
        assert!(html.contains("TEST-ORG"));
    }

    #[test]
    fn test_findings_in_report() {
        let mut report = create_test_report();
        report.findings.push(ComplianceFinding {
            severity: FindingSeverity::High,
            category: "Test".to_string(),
            description: "Test finding".to_string(),
            recommendation: "Fix it".to_string(),
        });
        
        let md = report.export(ReportFormat::Markdown);
        assert!(md.contains("Test finding"));
    }
}
